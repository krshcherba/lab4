# Аблаева Карина ИТ-3,4-2024 Лабораторная №3

# Задание 1
## Задача 2
### Без null
Создайте	сущность	Хранилище,	которая	обладает	следующими	характеристиками:
• Может	хранить	один	произвольный	объект	в	один	момент	времени.
• Хранилище	неизменяемо.
• Объект	 кладется	 в	 Хранилище	 при	 его	 создании.	 В	 качестве	 объекта	 может	 быть	
сохранено	также	и	значение	null.
• Хранилище	может	вернуть	ссылку	на	Объект.
• Если	 вместо	 объекта	 хранится	 null,	 необходимо	 вернуть	 какое-либо	 альтернативное	
значение.
• Метод	получения	значения	должен	работать	с	тем	типом	данных,	который	был	указан	во	
время	создания	объекта
Выполните	следующие	задания:
• Создайте	Хранилище	чисел,	положите	туда	значение	null.	Передайте	Хранилище	в	какойлибо	метод,	извлеките	 значение,	 и	 выведите	 его	 на	 экран.	 Альтернативой	 должно	 быть	
число	0.
• Создайте	 Хранилище	 чисел,	 положите	 туда	 значение	 99.	 Передайте	 Хранилище	 в	 какойлибо	метод,	 извлеките	 значение,	 и	 выведите	 его	 на	 экран.	 Альтернативой	 должно	 быть	
число	-1.
• Создайте	Хранилище	строк,	положите	туда	значение	null.	Передайте	Хранилище	в	какойлибо	метод,	 извлеките	 значение,	 и	 выведите	 его	 на	 экран.	 Альтернативой	 должна	 быть	
строка	“default”.
• Создайте	 Хранилище	 строк,	 положите	 туда	 значение	 “hello”.	 Передайте	 Хранилище	 в	
какой-либо	метод,	извлеките	значение,	и	выведите	его	на	экран.	Альтернативой	должна	
быть	строка	“hello world”.
### Алгоритм решения
package ru.ablaeva.model;

public final class Storage<T> {
    private final T object;

    public Storage(T object) {
        this.object = object;
    }

    public T get(T defaultValue) {
        return (this.object != null) ? this.object : defaultValue;
    }

    @Override
    public String toString() {
        return (this.object != null) ? this.object.toString() : "n/a";
    }
}

## Задача 5
### Обобщенная линия
Измените	сущность	Линия	из	задачи 2.6.3,	таким	образом,	чтобы
• При	создании	её	объекта	можно	было	точно	указать	тип	точки,	на	которой	расположена	
линия:	двухмерная	или	трехмерная	(из	задачи	2.3.5).	
• Методы	получения	и	установки	значения	Точки	также	могли	работать	с	типом	указанным	
при	создании	объекта.
• Граница	стирания	не	может	быть	хуже	двумерной	точки.
Создайте	и	выведите	на	экран	произвольную	линию	в	трехмерном	пространстве.
### Алгоритм решения
package ru.ablaeva.geometry;

import java.util.Objects;

public class Line<P> implements Cloneable {
    private P A, B;

    // создание линии через 2 точки
    public Line(P A, P B) {
        this.A = A;
        this.B = B;
    }

    // получение точек начала A и конца B линии
    public P getStart() { 
        return A; 
    }

    public P getEnd() { 
        return B; 
    } 

    // изменение координат точек
    public void setStart(P start) { 
        this.A = start; 
    }

    public void setEnd(P end) { 
        this.B = end; 
    }

    // вывод текстового представления сущности Линия
    @Override
    public String toString() {
        return "Линия от " + A + " до " + B;
    }
}

# Задание 2
## Задача 1
### Сдвинуть линию
Создайте метод,	 принимающий	 Линию	 из	 задачи	3.1.5 (с	 любой	 допустимой	 параметризацией)	сдвигающей	точку	начала	на	10	единиц	по	оси X.	Например,	если	X был	5,	то	должен стать	15,	если X был	-7, то	должен	стать	-17.
### Алгоритм решения
    // метод для сдвига точки начала на 10 единиц по оси х
    public void shiftStartX() {
        if (A instanceof Point) {
            Point pointA = (Point) A;
            int newX = pointA.getX() + 10;
            A = (P) new Point(newX, pointA.getY());
        }
        if (A instanceof Point3D) {
            Point3D pointA = (Point3D) A;
            int newX = pointA.getX() + 10;
            A = (P) new Point3D(newX, pointA.getY(), pointA.getZ());
        }
    }

# Задание 3
## Задача 1
### Функция
Разработайте	такой	метод,	который	будет	принимать	список	значений	типа	T,	и	объект	имеющий	
единственный	метод	apply.	Данный	метод	надо	применить	к	каждому	элементу	списка,	и	вернуть
новый	список	значений	типа	P,	при	этом	типы	T и	P могут	совпадать,	а	могут	не	совпадать.
Используйте	разработанный	метод	следующим	образом:
1. Передайте	 в	метод	 список	 со	значениями:“qwerty”,	 “asdfg”,	 “zx”,	а	получите	 список	 чисел,	
где	каждое	число	соответствует	длине	каждой	строки.
2. Передайте	 в	 метод	 список	 со	 значениями:	 1,-3,7,	 а	 получите	 список	 в	 котором	 все	
отрицательные	числа	стали	положительными,	а	положительные	остались	без	изменений
3. Передайте	 в	 метод	 список	 состоящий	 из	 массивов	 целых	 чисел,	 а	 получите	 список	 в	котором	будут	только	максимальные	значения	каждого	из	исходных	массивов.
### Алгоритм решения
public static <T, P> List<P> func(List<T> list1, Function<T, P> mapper) {
        List<P> list2 = new ArrayList<>();

        for (T t : list1) {
            list2.add(mapper.apply(t));
        }

        return list2;
    }

## Задача 2
### Фильтр
Разработайте	такой	метод,	который	будет	принимать	список	значений	типа	T и	объект	имеющий	
единственный	метод	test (принимает	T и	 возвращает	boolean).	Верните	новый	 список	 типа	T,	из	
которого	удалены	все	значения	не	прошедшие	проверку	условием.
Используйте	разработанный	метод	следующим	образом:
1. Передайте	 в	 метод	 список	 со	 значениями:	 “qwerty”,	 “asdfg”,	 “zx”, и	 отфильтруйте	 все	
строки	имеющие	менее	трех	символов
2. Передайте	 в	 метод	 список	 со	 значениями:	 1,-3,7,	 и	 отфильтруйте	 все	 положительные	
элементы
3. Передайте	 в	 метод	 список	 состоящий	 из	 массивов	 целых	 чисел,	 а	 получите	 список	 в	
котором	будут	только	те	массивы,	в	которых	нет	ни	одного	положительного	элемента.
### Алгоритм решения
public static <T> List<T> filter(List<T> list1, Predicate<T> mapper) {
        List<T> list2 = new ArrayList<>();

        for (T t : list1) {
            if (mapper.test(t)) {
                list2.add(t);
            }
        }

        return list2;
    }

## Задача 3
### Сокращение
Разработайте	такой	метод,	который	будет	принимать	список	значений	типа	T и	способ	с	помощью	
которого	 список	 значений	можно	 свести	 к	 одному	 значению	 типа	T,	 которое	 и	 возвращается	 из	
метода.	
Используйте	разработанный	метод	следующим	образом:
1. Передайте	 в	 метод	 список	 со	 значениями:	 	 “qwerty”,	 “asdfg”,	 “zx”, и	 сформируйте	 одну	
большую	строку,	которая	состоит	из	всех	строк исходного	списка.
2. Передайте	в	метод	список	со	значениями:	1,-3,7,	и	верните	сумму	всех	значений	исходного	
списка.
3. Имеется	 список, состоящий	 из	 списков	 целых	 чисел,	 получите	 общеe количество	
элементов	 во	 всех	 списках.	 Подсказка:	 решить	 задачу	 можно	 в	 одно	 действие	 или	
последовательно	использовать	методы	из	3.3.1 и	3.3.3.
Далее	 необходимо	 изменить	 разработанный	 метод	 таким	 образом,	 чтобы	 данный	 метод	
гарантированно	не	возвращал	null и	не	выбрасывал	ошибок	в	том	случае,	если	исходный	список	
пуст.
### Алгоритм решения
public static <T> T concat(List<T> list1, Function<List<T>,T> mapper) {
        T res = list1.get(0);

        for (int i = 1; i < list1.size(); i++) {
            res = mapper.apply(res, list1.get(i));
        }

        return res;
    }

## Задача 4
### Коллекционирование
Разработайте	 такой	метод,	 который	 будет	 возвращать	 коллекцию	 типа	P со	 значениями	 типа	T.	
Данный	метод	будет	принимать:
1. Список	исходных	значений
2. Способ	создания	результирующей	коллекции
3. Способ	передачи	значений	исходного	списка	в	результирующую	коллекцию.
Используйте	разработанный	метод	следующим	образом:
1. Передайте	 в	 метод	 список	 со	 значениями:	 1,-3,7,	 и верните	 их	 разбитыми	 на	 два	
подсписка,	 в	 одном	 из	 которых	 будут	 только	 положительные	 числа,	 а	 в	 другом	 только	
отрицательные.
2. Передайте	 в	 метод	 список	 со	 значениями:	 	 “qwerty”,	 “asdfg”,	 “zx”,	 “qw” и	 верните	 их	
разбитыми	на	подсписки	 таким	 образом,	 чтобы	 в	 любом	подсписке	 были	 строки	 только	
одинаковой	длины
3. Передайте	в	метод	список	со	значениями:		“qwerty”,	“asdfg”,	“qwerty”,	“qw” и	верните	набор	
такого	вида,	который	не	может	содержать	одинаковые	объекты.
### Алгоритм решения
    public static <T, P> List<P> collect(List<T> list1, Function<T, P> mapper) {
        List<P> list2 = new ArrayList<>();

        for (T t : list1) {
            list2.add(mapper.apply(t));
        }

        return list2;
    }